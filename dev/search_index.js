var documenterSearchIndex = {"docs":
[{"location":"api/","page":"-","title":"-","text":"AbstractConnection\nQOS\nconnect\nconnect!\nsubscribe\nsubscribe!\npublish\npublish!\nunsubscribe\nunsubscribe!\ndisconnect\ndisconnect!","category":"page"},{"location":"api/#MQTT.AbstractConnection","page":"-","title":"MQTT.AbstractConnection","text":"MQTTConnection\n\nAn abstract type representing a connection to an MQTT broker.\n\nMQTT (Message Queuing Telemetry Transport) is a lightweight, publish-subscribe, machine-to-machine network protocol for message queue/message queuing service. It is designed for connections with remote locations that have devices with resource constraints or limited network bandwidth, such as in the Internet of Things (IoT). It must run over a transport protocol that provides ordered, lossless, bi-directional connectionsâ€”typically, TCP/IP.\n\nAn MQTT client establishes a connection with the MQTT broker. Once connected, the client can either publish messages, subscribe to specific messages, or do both. When the MQTT broker receives a message, it forwards it to subscribers who are interested.\n\n\n\n\n\n","category":"type"},{"location":"api/#MQTT.QOS","page":"-","title":"MQTT.QOS","text":"QOS\n\nAn enum representing the different Quality of Service (QoS) levels in MQTT.\n\nValues\n\nAT_MOST_ONCE: QoS level 0, at most once delivery. The message is delivered at most once, or it may not be delivered at all. This is also known as \"fire and forget\".\nAT_LEAST_ONCE: QoS level 1, at least once delivery. The message is guaranteed to be delivered at least once, but it may be delivered multiple times.\nEXACTLY_ONCE: QoS level 2, exactly once delivery. The message is guaranteed to be delivered exactly once.\n\n\n\n\n\n","category":"type"},{"location":"getting-started/#MQTT.jl","page":"MQTT.jl","title":"MQTT.jl","text":"","category":"section"},{"location":"getting-started/#Installation","page":"MQTT.jl","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"Pkg.clone(\"https://github.com/JuliaMQTT/MQTT.jl.git\")","category":"page"},{"location":"getting-started/#Testing","page":"MQTT.jl","title":"Testing","text":"","category":"section"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"Pkg.test(\"MQTT\")","category":"page"},{"location":"getting-started/#Usage","page":"MQTT.jl","title":"Usage","text":"","category":"section"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"Import the library with the using keyword. This package has no default backend, so either AWSCRT or MQTTClient needs to be included.","category":"page"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"using MQTT, MQTTClient","category":"page"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"MQTT provides a MQTTConnection object for each backend, this struct is passed to the other included functions.","category":"page"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"client = MQTTClient.Client()\nconnection = MQTTClient.Connection()\n\nmqtt_connection = MQTTConnection(client, connection)","category":"page"},{"location":"getting-started/#Advanced-Usage","page":"MQTT.jl","title":"Advanced Usage","text":"","category":"section"},{"location":"getting-started/#Getting-started","page":"MQTT.jl","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"To use this library you need to follow at least these steps:","category":"page"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"Define any client data structures needed for a given backend.\nCreate an instance of the MQTTConnection struct passing the backend specific information.\nCall the connect method with your Client instance.\nExchange data with the broker through publish, subscribe and unsubscribe. When subscribing, pass your callback function for that topic.\nDisconnect from the broker. (Not strictly necessary, if you don't want to resume the session but considered good form and less likely to crash).","category":"page"},{"location":"getting-started/#Basic-example","page":"MQTT.jl","title":"Basic example","text":"","category":"section"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"Refer to the corresponding method documentation to find more options. Refer to the MQTT Client documentation for specifics about the client.","category":"page"},{"location":"getting-started/","page":"MQTT.jl","title":"MQTT.jl","text":"using MQTT, MQTTClient\nbroker = \"test.mosquitto.org\"\n\n# Define the callback for receiving messages.\nfunction on_msg(topic, payload)\n    info(\"Received message topic: [\", topic, \"] payload: [\", String(payload), \"]\")\nend\n\n# Instantiate a client.\nclient = MQTTClient.Client()\nconnection = MQTTClient.Connection()\nmqtt_connection = MQTTConnection(client, connection)\n\nconnect!(mqtt_connection)\n\n# Subscribe to the topic we will publish to.\nsubscribe!(mqtt_connection, \"jlExample\", on_msg, qos=AT_LEAST_ONCE))\n\npublish!(mqtt_connection, \"jlExample\", \"Hello World!\")\n\n# Unsubscribe from the topic\nunsubscribe!(mqtt_connection, \"jlExample\")\n\n# Disconnect from the broker. Not strictly needed as the broker will also\n#   disconnect us if the socket is closed. But this is considered good form\n#   and needed if you want to resume this session later.\ndisconnect!(mqtt_connection)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MQTT","category":"page"},{"location":"#MQTT","page":"Home","title":"MQTT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MQTT.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Package is a interface package for generic use functions with the goal of making MQTT package backends interchangeable.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"extensions.md\",\n  \"api.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"extensions/#Creating-MQTT-Backend-Extensions","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"","category":"section"},{"location":"extensions/#How-it-works","page":"Creating MQTT Backend Extensions","title":"How it works","text":"","category":"section"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"MQTT.jl uses the (new) Weak Deps features to allow multiple MQTT packages to be added as weak dependancies. ","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"Each MQTT client implimentation needs to have a extension added in the ext directory (and registered in the Project.toml).","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"These extensions and their packages they implement are only loaded if the end-user of this package adds it as a dependancy (only loading what you need).","category":"page"},{"location":"extensions/#Creating-an-Extension","page":"Creating MQTT Backend Extensions","title":"Creating an Extension","text":"","category":"section"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"To make a new Client functional an extension is created. The extension needs to implement the following interface functions that return asynchronous objects such as Tasks or Futures:","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"_connect(c::MQTTConnection): connect to a broker\n_subscribe(callback::Function, c::MQTTConnection, topic, qos::QOS): subscribe to a topic\n_publish(c::MQTTConnection, topic::String, payload::Vector{UInt8}, qos::QOS, retain::Bool): publish to a topic\n_unsubscribe(c::MQTTConnection, topic::String): unsubscribe from a topic\n_disconnect(c::MQTTConnection): disconnect from a broker","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"Aditionally the following utility function(s) need to be implemented:","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"_resolve(f): wrapper function for fetching a async result.","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"Most importantly the connection struct needs to be created.","category":"page"},{"location":"extensions/","page":"Creating MQTT Backend Extensions","title":"Creating MQTT Backend Extensions","text":"MQTTConnection this needs to be a subtype of AbstractConnection and contain all information specific to the MQTT Client that is being used.","category":"page"}]
}
